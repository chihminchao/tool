#!/usr/bin/env python

""" cross-compiler setup tool """
import argparse
import ConfigParser
import os
import re
import subprocess
import sys
import tempfile

def find_xtool_dir(path):
    """ find all valid x-tool direcotory under specific path
        Only search 8 level in the path
    """


    cmd = 'find %s/ -maxdepth 8 -name "*-*-*-*" -type d' % (path)
    rmsg = subprocess.Popen([cmd], stdout=subprocess.PIPE, shell=True)
    candidate = rmsg.communicate()[0].rstrip('\n').split('\n')

    search_list = []
    for item in candidate:
        bin_path = "%s/bin" % (item)
        include_path = "%s/include" % (item)

        if os.path.isdir(bin_path) and os.path.isdir(include_path):
            search_list.append(item)

    return search_list


def find_xtool_bin(path):
    """ find target name, gcc/gdb/readelf path for specific xtool dir """

    pattern = {"^a.*-.*-gcc$" : 'gcc',
               "^a.*-.*-gdb$" : 'gdb',
               "^a.*-.*-readelf$" : 'binutil'}
    ret = dict()
    prefix = ""

    for root, _, names in os.walk(path + "/bin"):
        for filename in names:
            for item in pattern.keys():
                if re.match(item, filename):
                    ret[pattern[item]] = {"path" : os.path.join(root, filename)}
                    if not prefix:
                        what = re.match(r'(a.*-.*-.*)-(\w*)', filename)
                        ret['target'] = what.group(1)

    if not ret:
        raise Exception('File not found')
    else:
        return ret


def find_xtool_info(xtool):
    """ find gcc/gdb/binutil verision information """

    #gcc
    try:
        xtool['vendor'] = "None"
        xtool['gcc']['version'] = "None"
        xtool['gcc']['abi'] = "None"
        xtool['gcc']['cpu'] = "None"
        xtool['gcc']['fpu'] = "None"

        rmsg = subprocess.Popen([xtool['gcc']['path'], "-v"], stderr=subprocess.PIPE)
        info = rmsg.communicate()[1].rstrip('\n').split('\n')

        version_info = info[-1]
        for line in info:
            if line.find("--build") > 0:
                build_info = line
                break

        what = re.match(r"gcc version ([\w\.]+) (.+)", version_info)
        xtool['vendor'] = what.group(2)
        xtool['gcc']['version'] = what.group(1)

        what = re.match(r".+ --with-float=(\w+)", build_info)
        if what:
            xtool['gcc']['abi'] = what.group(1)

        what = re.match(r".+ --with-cpu=(\w+)", build_info)
        if what:
            xtool['gcc']['cpu'] = what.group(1)

        what = re.match(r".+ --with-fpu=(\w+)", build_info)
        if what:
            xtool['gcc']['fpu'] = what.group(1)

    except Exception:
        pass


    #binutil
    try:
        xtool['binutil']['version'] = "None"

        rmsg1 = subprocess.Popen([xtool['binutil']['path'], "-v"], stdout=subprocess.PIPE)
        rmsg2 = subprocess.Popen(["head", "-1"], stdin=rmsg1.stdout, stdout=subprocess.PIPE)
        rmsg1.stdout.close()

        version = rmsg2.communicate()[0].rstrip('\n')
        what = re.match("(.+) (.+)$", version)

        xtool['binutil']['version'] = what.group(2)
    except Exception:
        pass


    #gdb
    try:
        if not 'gdb' in xtool:
            xtool['gdb'] = dict()

        xtool['gdb']['version'] = "None"

        rmsg1 = subprocess.Popen([xtool['gdb']['path'], "-v"], stdout=subprocess.PIPE)
        rmsg2 = subprocess.Popen(["head", "-1"], stdin=rmsg1.stdout, stdout=subprocess.PIPE)
        rmsg1.stdout.close()

        version = rmsg2.communicate()[0].rstrip('\n')
        what = re.match("(.+) (.+)$", version)

        xtool['gdb']['version'] = what.group(2)
    except Exception:
        pass


def show_xtool_info(xtools):
    """ search gcc/gdb information in each cross compiler folder """
    prefix_len  = max([len(item['target'])             for item in xtools.values()])
    gcc_len     = max([len(item['gcc']['version'])     for item in xtools.values()])
    abi_len     = max([len(item['gcc']['abi'])         for item in xtools.values()])
    vendor_len  = max([len(item['vendor'])     for item in xtools.values()])

    cell_format = "%%s%%-3s%%-%ds%%-%ds%%-%ds%%-%ds" % (
                            prefix_len + 1,
                            gcc_len + 1,
                            abi_len + 1,
                            vendor_len + 1)

    print cell_format % (" ", "", 'Target', 'gcc', "abi", "vendor")
    idx = 1
    for item in sorted(xtools.itervalues(), key=lambda x: x['gcc']['version']):
        if item['current']:
            cur_mark = "*"
        else:
            cur_mark = " "

        print cell_format % (cur_mark, idx,
                                  item['target'],
                                  item['gcc']['version'],
                                  item['gcc']['abi'],
                                  item['vendor'])
        idx += 1


def search_xtool(lookup_path=None):
    """ find possible xtool in specific dir and get each information for
        gcc/gdb/binutils
    """

    if not lookup_path:
        home = os.getenv('HOME')
        toolpath = os.getenv('TOOLBOX', home + "/tool")
        if not toolpath:
            print "can't get home directory"
            exit(1)

        xtoolpath = toolpath + "/x-tools"

        select_list = find_xtool_dir(xtoolpath)

    else:
        if os.path.isdir(lookup_path):
            select_list = [lookup_path, ]

    xtools = dict()
    for item in select_list:
        try:
            xtools[item] = find_xtool_bin(item)
        except Exception:
            print 'ignore : ' + item
            continue

        find_xtool_info(xtools[item])

    # find and setup current xtool path
    arm_path = os.getenv('ARM_TOOLPATH')
    aarch64_path = os.getenv('AARCH64_TOOLPATH')
    for item in xtools.keys():
        if arm_path and arm_path == item:
            xtools[item]['current'] = True
        elif aarch64_path and aarch64_path == item:
            xtools[item]['current'] = True
        else:
            xtools[item]['current'] = False

    return xtools


def get_choice(xtools):
    " Get integer input from prompt. 'q' for leave "

    while True:
        try:
            choice = raw_input("Choice [q for quit] : ")
            if choice == 'q':
                choice = 0
                break
            elif choice.isalnum() and 1 <= int(choice) <= len(xtools):
                break
            else:
                pass

        except ValueError:
            pass

    return int(choice)


def access_config(writedata, option, value=None):
    """ accsss the section.field in the config file

    Args:
        writedate : True -> update value
        option : section.field   ex : xtool.arm_toolchain
        value : new value if writedata is True
    Return:
        None : get nothin
        value
    """
    config = os.getenv('HOME') + "/." + os.getenv('USER') + "-tool/config"
    catagory, field = option.split('.')

    if writedata and value == None:
        raise Exception("Invalid value for write")

    if not os.path.exists(config):
        raise Exception("config directory (%s) doesn't exist" % config)

    content = ConfigParser.SafeConfigParser()
    try:
        content.read(config)
    except:
        raise Exception("parse %s config error" % config)

    if not content.has_section(catagory):
        raise Exception("config file doesn't have '%s' section" % catagory)

    if writedata:
        content.set(catagory, field, value)
        tmpfp = open(config, "w")
        content.write(tmpfp)
        return value
    else:
        try:
            val = content.get(catagory, field)
        except Exception:
            raise Exception(("config file doesn't have '%s'"
                            "field in '%s' section") % (field, catagory))
        return val
    return None


def parse_argv():
    """ parse command line argument """
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
            description=("cross toolchain setup tool\n"
                         "The tool search config in the following order\n"
                         "    1. $XTOOL_DIR\n"
                         "    2. $HOME/tool/x-tools\n"))

    parser.add_argument("-l", "--list",
                        action="store_true", dest="listall", default=False,
                        help="List available toolchain version")
    parser.add_argument("-d", "--dry",
                        action="store_true", dest="dryrun", default=False,
                        help="Don't take an effect")
    parser.add_argument("-c", "--current",
                        action="store_true", dest="current", default=False,
                        help="Look up current tool version")
    parser.add_argument("-o", "--override",
                        action="store_true", dest="override", default=False,
                        help="Override global config for each new shell")
    parser.add_argument("-t", "--tmp",
                        action="store_false", dest="override",
                        help="Write path to tempory file, specified by config. "
                             "If the file doesn't exist, generate it")

    return parser.parse_args()

def setup_config():
    """ create config folder if it doesn't exist """

    config_folder = "%s/.%s-tool" % (os.getenv('HOME'), os.getenv('USER'))
    config_file = "%s/config" % (config_folder)
    config_template = ("[xtools]\n"
                       "arm_toolpath =\n"
                       "arm_tmp =\n"
                       "aarch64_toolpath =\n"
                       "aarch64_tmp =\n")

    if not os.path.exists(config_folder):
        os.makedirs(config_folder)

    if not os.path.exists(config_file):
        with open(config_file, "w") as handler:
            handler.writelines(config_template)


def run(cmd_opts):
    """ main body """

    setup_config()

    if cmd_opts.listall:
        xtools = search_xtool()
        show_xtool_info(xtools)

        sys.exit(0)

    if cmd_opts.current:
        ret = access_config(writedata=False, option="xtools.arm_toolpath")
        xtools = search_xtool(ret)

        print "arm x-tool"
        show_xtool_info(xtools)

        print "\naarch64 x-tool"
        ret = access_config(writedata=False, option="xtools.aarch64_toolpath")
        xtools = search_xtool(ret)

        show_xtool_info(xtools)

        sys.exit(0)

    if cmd_opts.dryrun or cmd_opts.override or not cmd_opts.override:
        xtools = search_xtool()
        show_xtool_info(xtools)
        choice = get_choice(xtools)

        if choice:
            choice = int(choice) - 1
            path = sorted(xtools.keys(), key=lambda x: xtools[x]['gcc']['version'])[choice]

            basename = os.path.basename(path)
            if "arm" in basename:
                arch = "arm"
            elif "aarch64":
                arch = "aarch64"
            else:
                print "Unknown arch '%s'" % (arch)

            if cmd_opts.dryrun:
                print "just try run"
            elif cmd_opts.override:
                ret = access_config(writedata=True,
                                    option="xtools.%s_toolpath" % (arch), value=path)
                if ret == path:
                    print "Overrite success"
                else:
                    print "Overrite fail"
            else:
                ini_field = "xtools.%s_tmp" % (arch)
                tmppath = access_config(writedata=False, option=ini_field)
                if not tmppath or not os.path.exists(tmppath):
                    tmpfp, tmppath = tempfile.mkstemp()
                    tmpfp = os.fdopen(tmpfp, "w")
                else:
                    tmpfp = open(tmppath, "w")
                    tmpfp.seek(0, 2)

                tmpfp.write(path + "\n")
                access_config(writedata=True, option=ini_field, value=tmppath)
                tmpfp.close()
                print "Tempory write  success"

        sys.exit(0)


    #should not be here
    print "unknown error"
    sys.exit(1)


if __name__ == "__main__":
    CMD_OPTS = parse_argv()
    run(CMD_OPTS)


