#!/usr/bin/env python
import os
import re
import subprocess
import optparse 
import ConfigParser
import tempfile

def find_xtool_dir(path):
    """ find all valid x-tool direcotory under specific path """

    select_list = []
    search_list = [path, ]
    new_list = []

    while search_list :
        for item in search_list :
            new_list += [item + "/" + path for path in os.listdir(item)]

        del search_list[:]

        for item in new_list :
            if os.path.isdir(item + "/bin"):
                select_list.append(item)
            else:
                search_list.append(item)

        del new_list[:]

    return select_list

def find_xtool_bin(path):
    """ find target name, gcc/gdb/readelf path for specific xtool dir """

    pattern = {"^arm-.*-gcc$" : 'gcc',
               "^arm-.*-gdb$" : 'gdb',
               "^arm-.*-readelf$" : 'binutil'}
    ret = dict()
    prefix = ""

    for root, dirs, names in os.walk(path + "/bin"):
        for filename in names:
            for item in pattern.keys():
                if re.match(item, filename):
                    ret[pattern[item]] = {"path" : os.path.join(root, filename)}
                    if not prefix:
                        m = re.match('(arm-.*-.*)-(\w*)', filename)
                        ret['target'] = m.group(1)

    if not ret:
        raise Exception('File not found')
    else:
        return ret

def find_xtool_info(xtool):
    """ find gcc/gdb/binutil verision information """

    #gcc
    try:
        xtool['vendor'] = "None"
        xtool['gcc']['version'] = "None"
        xtool['gcc']['abi'] = "None"
        xtool['gcc']['cpu'] = "None"
        xtool['gcc']['fpu'] = "None"

        p1 = subprocess.Popen([xtool['gcc']['path'], "-v"], stderr=subprocess.PIPE)
        info = p1.communicate()[1].rstrip('\n').split('\n')

        version_info = info[-1]
        for line in info:
            if line.find("--build") > 0:
                build_info = line
                break

        m = re.match("gcc version ([\w\.]+) (.+)", version_info)
        xtool['vendor'] = m.group(2)
        xtool['gcc']['version'] = m.group(1)

        m = re.match(".+ --with-float=(\w+)", build_info)
        if m:
            xtool['gcc']['abi'] = m.group(1)

        m = re.match(".+ --with-cpu=(\w+)", build_info)
        if m:
            xtool['gcc']['cpu'] = m.group(1)

        m = re.match(".+ --with-fpu=(\w+)", build_info)
        if m:
            xtool['gcc']['fpu'] = m.group(1)
            
    except:
        pass


    #binutil
    try:
        xtool['binutil']['version'] = "None"

        p1 = subprocess.Popen([xtool['binutil']['path'], "-v"], stdout=subprocess.PIPE)
        p2 = subprocess.Popen(["head", "-1"], stdin=p1.stdout, stdout=subprocess.PIPE)
        p1.stdout.close()

        version = p2.communicate()[0].rstrip('\n')
        m = re.match("(.+) (.+)$", version)

        xtool['binutil']['version'] = m.group(2)
    except:
        pass


    #gdb
    try:
        if not 'gdb' in xtool:
            xtool['gdb'] = dict()

        xtool['gdb']['version'] = "None"

        p1 = subprocess.Popen([xtool['gdb']['path'], "-v"], stdout=subprocess.PIPE)
        p2 = subprocess.Popen(["head", "-1"], stdin = p1.stdout, stdout=subprocess.PIPE)
        p1.stdout.close()

        version = p2.communicate()[0].rstrip('\n')
        m = re.match("(.+) (.+)$", version)

        xtool['gdb']['version'] = m.group(2)
    except:
        pass


def show_xtool_info(xtools):
    prefix_len  = max([ len(item['target'])             for item in xtools.values() ])
    gcc_len     = max([ len(item['gcc']['version'])     for item in xtools.values() ])
    abi_len     = max([ len(item['gcc']['abi'])         for item in xtools.values() ])

    cell_format = "%%s%%-3s%%-%ds%%-%ds%%-%ds" % (
                            prefix_len + 1, 
                            gcc_len + 1, 
                            abi_len + 1)

    print cell_format % ("", "", 'Target', 'gcc', "abi")
    idx = 1 
    for item in sorted(xtools.itervalues(), key=lambda x : x['gcc']['version']):
        if item['current']: 
            cur_mark = "*"
        else:
            cur_mark = " "

        print cell_format % (cur_mark, idx, 
                                  item['target'], 
                                  item['gcc']['version'],
                                  item['gcc']['abi'])
        idx += 1


def search_xtool(lookup_path = None):
    """ find possible xtool in specific dir and get each information for
        gcc/gdb/binutils
    """

    if not lookup_path:
        home = os.getenv('HOME')
        toolpath = os.getenv('TOOLBOX', home + "/tool")
        if not toolpath :
            print "can't get home directory"
            exit(1)

        xtoolpath = toolpath + "/x-tools"

        select_list = find_xtool_dir(xtoolpath)
            
    else:
        if os.path.isdir(lookup_path):
            select_list = [lookup_path, ]

    xtools = dict()
    for item in select_list:
        try:
            xtools[item] = find_xtool_bin(item)
        except:
            print 'ignore : ' + item
            continue

        find_xtool_info(xtools[item])
        
    # find and setup current xtool path
    cur_path = os.getenv('ARM_TOOLPATH')
    for item in xtools.keys():
        if cur_path and cur_path == item:
            xtools[item]['current'] = True
        else:
            xtools[item]['current'] = False
            
    return xtools


def get_choice(xtools):
    " Get integer input from prompt. 'q' for leave "

    while True :
        try:
            choice = raw_input("Choice [q for quit] : ")
            if choice == 'q':
                choice = 0
                break
            elif choice.isalnum() and 1 <= int(choice) <= len(xtools):
                break
            else:
                pass

        except ValueError:
            pass

    return int(choice)

def access_config(writedata, option, value = None):
    config = os.getenv('HOME') + "/." + os.getenv('USER') + "-tool/config"
    catagory, field = option.split('.')

    if writedata and value == None:
        raise Exception("Invalid value for write")

    if not os.path.exists(config):
        raise Exception("config directory (%s) doesn't exist" % config)

    content = ConfigParser.SafeConfigParser()
    try:
        content.read(config)
    except:
        raise Exception("parse %s config error" % config)

    if not content.has_section(catagory):
        raise Exception("config file doesn't have '%s' section" % catagory)

    if writedata:
        content.set(catagory, field, value)
        fp = open(config, "w")
        content.write(fp)
        return value
    else:
        val = content.get(catagory, field)
        if not val:
            raise Exception("config file doesn't have '%s' field in '%s' section" % (field, catagory))  
        return val
    return None

#
# main starat
#
parser = optparse.OptionParser()
parser.add_option("-l", "--list", 
                    action="store_true", dest="listall", default=False,
                    help="List available toolchain version")
parser.add_option("-d", "--dry", 
                    action="store_true", dest="dryrun", default=False,
                    help="Don't take an effect")
parser.add_option("-c", "--current", 
                    action="store_true", dest="current", default=False,
                    help="Look up current tool version")
parser.add_option("-o", "--override", 
                    action="store_true", dest="override", default=False,
                    help="Override global config for each new shell")
parser.add_option("-t", "--tmp", 
                    action="store_false", dest="override",
                    help="Write path to tempory file, specified by config. "
                         "If the file doesn't exist, generate it")

(options, args) = parser.parse_args()

if options.listall:
    xtools = search_xtool()
    show_xtool_info(xtools)
elif options.current:
    ret = access_config(False, "xtools.toolpath")
    xtools = search_xtool(ret)
    show_xtool_info(xtools)
elif options.dryrun or options.override or not options.override:
    xtools = search_xtool()
    show_xtool_info(xtools)
    choice = get_choice(xtools)

    if choice:
        choice = int(choice) - 1
        path = sorted(xtools.keys(), key=lambda x: xtools[x]['gcc']['version'])[choice]
        if options.dryrun:
            print "just try run"
        elif options.override:
            ret = access_config(True, "xtools.toolpath", path)
            if ret == path:
                print "Overrite success"
            else:
                print "Overrite fail"
        else:
            tmppath = access_config(False, "xtools.tmp")
            if not tmppath or not os.path.exists(tmppath):
                tmpfp, tmppath = tempfile.mkstemp()
                tmpfp = os.fdopen(tmpfp, "w")
            else:
                tmpfp = open(tmppath, "w")
                tmpfp.seek(0, 2)

            tmpfp.write(path + "\n")
            access_config(True, "xtools.tmp", tmppath)
            tmpfp.close()
            print "Tempory write  success"
else:
    parser.print_help()



   
