#!/usr/bin/env python
import os
import sys
import re
import subprocess
import optparse 
import ConfigParser
import tempfile

def find_xtool_dir(path):
    """ find all valid x-tool direcotory under specific path """

    select_list = []
    search_list = [path, ]
    new_list = []

    while search_list :
        for item in search_list :
            new_list += [item + "/" + path for path in os.listdir(item)]

        del search_list[:]

        for item in new_list :
            if os.path.isdir(item + "/bin"):
                select_list.append(item)
            else:
                search_list.append(item)

        del new_list[:]

    return select_list

def find_xtool_bin(path):
    """ find target name, gcc/gdb/readelf path for specific xtool dir """

    pattern = {"^arm-.*-gcc$" : 'gcc',
               "^arm-.*-gdb$" : 'gdb',
               "^arm-.*-readelf$" : 'binutil'}
    ret = dict()
    prefix = ""

    for root, dirs, names in os.walk(path + "/bin"):
        for filename in names:
            for item in pattern.keys():
                if re.match(item, filename):
                    ret[pattern[item]] = {"path" : os.path.join(root, filename)}
                    if not prefix:
                        m = re.match('(arm-.*-.*)-(\w*)', filename)
                        ret['target'] = m.group(1)

    if not ret:
        raise Exception('File not found')
    else:
        return ret

def find_xtool_info(xtool):
    """ find gcc/gdb/binutil verision information """

    #gcc
    try:
        xtool['vendor'] = None
        xtool['gcc']['version'] = None
        xtool['gcc']['abi'] = None
        xtool['gcc']['cpu'] = None
        xtool['gcc']['fpu'] = None

        p1 = subprocess.Popen([xtool['gcc']['path'],"-v"], stderr=subprocess.PIPE)
        p2 = subprocess.Popen(["tail", "-1"], stdin = p1.stderr, stdout=subprocess.PIPE)
        p1.stderr.close()

        version = p2.communicate()[0].rstrip('\n')

        m = re.match("(\w+) (\w+) ([\w\.]+) (.+)", version)
        xtool['vendor'] = m.group(4)
        xtool['gcc']['version'] = m.group(3)
        
    except:
        pass


    #binutil
    try:
        xtool['binutil']['version'] = None

        p1 = subprocess.Popen([xtool['binutil']['path'], "-v"], stdout=subprocess.PIPE)
        p2 = subprocess.Popen(["head", "-1"], stdin=p1.stdout, stdout=subprocess.PIPE)
        p1.stdout.close()

        version = p2.communicate()[0].rstrip('\n')
        m = re.match("(.+) (.+)$", version)

        xtool['binutil']['version'] = m.group(2)
    except:
        pass


    #gdb
    try:
        xtool['gdb']['version'] = None

        p1 = subprocess.Popen([xtool['gdb']['path'], "-v"], stdout=subprocess.PIPE)
        p2 = subprocess.Popen(["head", "-1"], stdin = p1.stdout, stdout=subprocess.PIPE)
        p1.stdout.close()

        version = p2.communicate()[0].rstrip('\n')
        m = re.match("(.+) (.+)$", version)

        xtool['gdb']['version'] = m.group(2)
    except:
        pass


def show_avalable_tool(xtools_list):
    prefix_len  = max([ len(item['prefix'])     for item in xtools_list ])
    vendor_len  = max([ len(item['vendor'])     for item in xtools_list ])
    gcc_len     = max([ len(item['gcc'][2])     for item in xtools_list if item['gcc'][2] ] )
    binutil_len = max([ len(item['binutil'][2]) for item in xtools_list if item['binutil'][2] ] )
    gdb_len     = max([ len(item['gdb'][2])     for item in xtools_list if item['gdb'][2] ] )

    cell_format = "%%-3s%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds" % (prefix_len + 1, vendor_len + 1, gcc_len + 1, binutil_len + 1, gdb_len + 1)

    print cell_format % ("", 'Platform', 'Vendor', 'gcc', 'binutils', 'gdb')
    for idx, item in enumerate(xtools_list):
        print cell_format % (idx + 1, item['prefix'], 
                                                          item['vendor'], 
                                                          item['gcc'][2], 
                                                          item['binutil'][2], 
                                                          item['gdb'][2])


def search_xtool(lookup_path = None):
    """ find possible xtool in specific dir and get each information for
        gcc/gdb/binutils
    """

    if not lookup_path:
        home = os.getenv('HOME')
        toolpath = os.getenv('TOOLBOX', home + "/tool");
        if not toolpath :
            print "can't get home directory"
            exit(1)

        xtoolpath = toolpath + "/x-tools"

        select_list = find_xtool_dir(xtoolpath)
    else:
        if os.path.isdir(lookup_path):
            select_list = [lookup_path, ]

    xtools = dict()
    for item in select_list:
        try:
            xtools[item] = find_xtool_bin(item)
        except:
            print 'ignore : ' + item
            continue

        find_xtool_info(xtools[item])
        
    return xtools


def get_choice():
    while True :
        try:
            choice = raw_input("Choice [q for quit] : ")
            if choice == 'q':
                choice = 0
                break
            elif choice.isalnum() and 1 <= int(choice) <= len(xtools_list):
                break
            else:
                pass

        except ValueError:
            pass

    return int(choice)

def access_config(writedata, option, value = None):
    config = os.getenv('HOME') + "/." + os.getenv('USER') + "-tool/config"
    catagory, field = option.split('.')

    if writedata and value == None:
        print "Invalid value for write"
        return None

    if not os.path.exists(config):
        print "config directory (%s) doesn't exist" % config
        return None

    content = ConfigParser.SafeConfigParser()
    try:
        content.read(config)
    except:
        print "parse %s config error" % config
        return None

    if not content.has_section(catagory):
        print "config file doesn't have '%s' section" % catagory
        return None

    if writedata:
        content.set(catagory, field, value)
        fp = open(config, "w")
        content.write(fp)
        return value
    else:
        val = content.get(catagory, field)
        if not val:
            print "config file doesn't have '%s' field in '%s' section" % (field, catagory)
            return None
        return val
    return None

#
# main starat
#
parser = optparse.OptionParser()
parser.add_option("-l", "--list", 
                    action="store_true", dest="listall", default=False,
                    help="List available toolchain version")
parser.add_option("-d", "--dry", 
                    action="store_true", dest="dryrun", default=False,
                    help="Don't take an effect")
parser.add_option("-c", "--current", 
                    action="store_true", dest="current", default=False,
                    help="Look up current tool version")
parser.add_option("-o", "--override", 
                    action="store_true", dest="override", default=False,
                    help="Override global config for each new shell")
parser.add_option("-t", "--tmp", 
                    action="store_false", dest="override",
                    help="Write path to tempory file, specified by config. "
                         "If the file doesn't exist, generate it")

(options, args) = parser.parse_args()

if options.listall:
    xtools_list = search_xtool()
    show_avalable_tool(xtools_list)
elif options.current:
    ret = access_config(False, "xtools.toolpath")
    xtools_list = search_xtool(ret)
    show_avalable_tool(xtools_list)
elif options.dryrun or options.override or not options.override:
    xtools_list = search_xtool()
    show_avalable_tool(xtools_list)
    choice = get_choice()

    if choice:
        choice = int(choice) - 1
        if options.dryrun:
            print "just try run"
        elif options.override:
            ret = access_config(True, "xtools.toolpath", xtools_list[choice]['path'])
            if ret == xtools_list[choice]['path']:
                print "Overrite success"
            else:
                print "Overrite fail"
        else:
            tmppath = access_config(False, "xtools.tmp")
            if not tmppath or not os.path.exists(tmppath):
                tmpfp, tmppath = tempfile.mkstemp();
                tmpfp = os.fdopen(tmpfp, "w")
            else:
                tmpfp = open(tmppath, "w")
                tmpfp.seek(0, 2)

            tmpfp.write(xtools_list[choice]['path'] + "\n")
            access_config(True, "xtools.tmp", tmppath)
            tmpfp.close()
            print "Tempory write  success"
else:
    parser.print_help()



   
